here's my type system:


a tag is an identifier associated with a program element

a org is a special list

an org can have children that are tagged

at evaluation time, if an expression is tagged, the evaluator will check after evaluation
to see whether the expression evaluated to an org. If it did, then the evaluator will
retrieve the child matching the tag.

if an expression has multiple tags, the evaluator will resolve them in the order they are specified,
and use the first one that works.

It is not an error if the returned org doesn't have that tag (unless strict mode?)

If dereferencing the tag returns another org, the evaluator will dereference again. It will keep dereferencing until:
1. the dereferencing step stops returning orgs 2. it runs out of matching tags

a kind is a list of tags associated with actual types (lambda, int, org, etc)

a type is a tag that maps to a kind

if an org matches a kind, it means that it has a matching child for each item in the kind

if a type exists, a checker will prevent you from tagging a nex with that type's tag unless it matches that type's kind

function params can have specifiers which limit you to only passing orgs of a certain type





TESTS = crucial
- test for equal
- some tests for object tags
- copy and paste tests (same as 2?)
- tests for run-js
- tests for cram and chop
- test for to-word
- tests for all async primitives
- go over all checkins over the past month and figure out what tests are missing
- need test for partial-exploded mode ,it doesn't work because esc is integral to my test recording framework
- I should have a test for each type of error location to make sure error propagation doesn't get broken. so basically any place that evaluateNexSafely is called
- test for to-float
- tests for catch, eval


BUGFIXES = necessary
- fix bug where you can eval a symbol and then change code that is being executed async by an expectation
- fix problem with the set-style function where it creates an infinite loop of expectations
- make it impossible for wrap-expectation to go on forever.
- step eval is mostly broken, fix (FOR STEP EVAL FIXES SEE CODE CLEANUP SECTION)
- executing a subexpression when you're in the middle of step evaluating is broken: specifically::: execution_stepeval_bindwithnormal is broken because somehow when you are step evaluating and you click on a subexpression with bound environment and you normal-eval it, if you click on the result of that inner normal-eval inside its expectation, and shift-tab to go to the parent YOU DON'T GO ANYWHERE. why.  (FOR STEP EVAL FIXES SEE CODE CLEANUP SECTION)
- trying to load a file that doesn't exist crashes the server
- saving a file with an error in it only saves the top-level error not the enclosed errors.


CODE CLEANUP = good
- make a better naming convention for js global variables decide what's a const and what's a singleton and generally what's what.
- update ILVL (it's been renamed to stackLevel) in step eval
- come up with a better naming convention for global objects
- handle insertion points at the render node level
- get rid of that carriage return object and use insertion point for that
- rename getFulfilledThing to fulfill
- use regexes in the event table to clean up the event tables
- remove old edit primitive
- fix render node hacks in estring class coming from the normal/expanded drawing logic
- remove dead code from eerror class because it can't be drawn in expanded mode anymore
- figure out what to do in run-js if no DOM object (throw exception? create one?)
- change the step eval stuff so that alt-enter changes the selected item rather than maintaining a stack (NOTE: this is probably better to do than fix any of the existing step eval stuff)
- remove makeCopy/js array hack in Environment.lb
- BuiltinParamManager and BuiltinArgEvaluator do the same thing, merge somehow


PERFORMANCE FIXES = recommended
- use "dirty-only" rendering everywhere it is possible to use it
- instanceof checks are slow, for nexes instead compare to getTypeName()


USABILITY IMPROVEMENTS = nice to have
- rename *-functions files to *-library
- rename library functions so that the library name is in the function name - OR implement a package grouping system of some kind
- make it so you can specify arg type with the codes I use in the builtin param names, and that you can have them in lambdas.
- tags precede rather than follow content
- start using exclamation points for primitives that set values like in regular lisp, like apply-style-to


NEW FEATURES = be careful
- short circuit evaluation for conditionals
- make it so you can change exploded/normal in code by setting a tag
- make a tag type that is sort of an enum (like radio buttons)
- make a "toggle" tag type (like a form checkbox)
- make the thing that changes error types use tags to designate the desired error type
- make a list type that is just "list" that can be vert/horiz, looks like a command or lambda but without the symbol, and which, when you evaluate it, replaces each of its children with the result of evaluating that child
- backtick does operations on tags
- implement to-word for lines and docs
- implement "equal" for list types (needs to be deep equal)
- make native primitives for some common operations that could be bootstrapped (like iteration)
- make "type creation" primitives (make-integer, make-float, etc)
- make the ff primitives use "skip eval" but test arguments to see if they are
  already expectations and if so just use, otherwise eval argument.


EXPERIMENTS TO TRY = be extra careful
- get rid of insertion points and switch to pre- and post- inserts
- try voice commands
- make arithmetic functions use plus, minus words instead of symbols
- make docs so that !#$ characters add those literal characters and the only ones that work are ~@
- use a different key for modifying string contents rather than shift-enter
- try having different ctrl/alt/shift chords for insert/append/prepend/enclose versions of !@#$



