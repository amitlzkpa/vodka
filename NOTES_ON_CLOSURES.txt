When a function creates multiple closures, each one needs its own set of symbols
that can vary independently.

let f = function() {
    let a = [];
    for (let i = 0;i < 10; i++) {
        let r = Math.random();
        a.push(function() {
            console.log(r);
        });
    }
    return a;
}
let m = f();
m[0](); // prints 0.4358334282486591
m[1](); // prints 0.8695053811494855
m[0](); // prints 0.4358334282486591

When we do copy, we can make shallow copies - example:

let f = function() {
   let a = [1, 2, 3];
   let funcs = [];
   for (let i = 0; i < 10; i++) {
      funcs.push(function() {
         console.log(a[0]);
         a[0] = i;
      });
   }
   return funcs;
}

let fs = f();
fs[0](); // prints 1
fs[3](); // prints 0
fs[0](); // prints 3

Each function gets its own private copy of a that it can modify, but the contents of a are shared.


/*
let f = function() {
    let a = [];
    for (let i = 0;i < 10; i++) {
        let r = Math.random();
        a.push(function() {
            console.log(r);
        });
    }
    return a;
}
let m = f();
m[0]();
 // prints 0.4358334282486591
m[1]();
 // prints 0.8695053811494855
m[0]();
 // prints 0.4358334282486591

the lambda needs to return a closure when it is evaluated
a closure needs to be a separate object
a closure has a pointer to an environment
the environment that it points to is a copy, going ALL THE WAY UP THE STACK TO THE ROOT
of the environment that existed at the time the lambda was evaluated
